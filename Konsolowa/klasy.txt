-arkusze zima 2024 oba
-klasy (definiuje konstruktory , zakres widoczności pól)

Konstruktory: - metoda wywołana w momencie uruchomienia aplikacji. Cel - zainicjownaie pól obiektu

Python : 

class Samochod:
	def __init__(self, marka, model): #Definicja konstruktora __init__
		self.marka = marka # tu wlasnie jest inicjalizacja pol / Przypisanie argumentu 'marka' do pola obiektu 'self.marka'
		self.model = model #Przypisanie argumentu 'model' do pola obiektu 'self.model'

auto = Samochod("Tesla", "S") #Tworzenie instancji klasy (wywołanie konstruktora)
#W pythonie konstruktorem jest metoda __init__. Pierwszym argumentem musi być self, bo reprezentuje tworzony obiekt

class Pracownik: #Definicja nowej klasy.
    def __init__(self, imie, pensja):
        self.imie = imie          # Publiczne: dostępny wszędzie
        self.__pensja = pensja    # Prywatne: ukryte przed dostępem z zewnątrz / Użycie __ powoduje zmianę nazwy pola w pamięci, co uniemożliwia bezpośredni dostęp z zewnątrz.

    def wyswietl_dane(self):
        # Dostęp do pola prywatnego jest możliwy wewnątrz klasy
        print(f"Pracownik: {self.imie}, Zarobki: {self.__pensja}")

    def daj_podwyzke(self, procent):
        if procent > 0:
            self.__pensja *= (1 + procent / 100)

# Użycie:
p1 = Pracownik("Jan", 5000)
p1.daj_podwyzke(10)      # Metoda modyfikuje ukryte pole
p1.wyswietl_dane()       # Metoda odczytuje ukryte pole
# print(p1.__pensja)     # BŁĄD! Python zgłosi AttributeError

C++:

class Samochod {
public: // pola będą widoczne wszędzie
    string marka;
    string model;

    // Konstruktor z tzw. listą inicjalizacyjną
    Samochod(string m, string mod) : marka(m), model(mod) {
        //Wnętrze konstruktora (puste, bo dane już przypisano)
    }
};

// Stworzenie obiektu na stosie
Samochod auto("Tesla", "S");


#include <iostream>
#include <string>
using namespace std;

class Pracownik {
private:
    double pensja; // Pole prywatne 

public:
    string imie;   // Pole publiczne

    // Konstruktor z listą inicjalizacyjną (wydajniejszy)
    Pracownik(string i, double p) : imie(i), pensja(p) {}

    // Metoda publiczna (tzw. getter) do odczytu prywatnego pola
    void pokazDane() {
        cout << imie << " zarabia: " << pensja << endl;
    }

    // Metoda publiczna (tzw. setter) z logiką walidacji
    void ustawPensje(double nowaPensja) {
        if (nowaPensja > 0) pensja = nowaPensja;
    }
};

int main() {
    Pracownik p("Anna", 6000);
    p.imie = "Joanna";     // OK - imie jest publiczne
    // p.pensja = 7000;    // BŁĄD KOMPILACJI - pensja jest prywatna
    p.ustawPensje(7500);   // OK - zmieniamy przez oficjalną metodę
    p.pokazDane();
    return 0;
}


C#:


public class Samochod {
    //  Deklaracja pól publicznych
    public string Marka;
    public string Model;

    // Definicja konstruktora
    public Samochod(string marka, string model) {
        // Słowo 'this' wskazuje na pole klasy
        this.Marka = marka; //Słowo this mówi kompilatorowi: "this.Marka to to pole u góry, a marka to wartość z nawiasu".
        this.Model = model;
    }
}

// Użycie słowa kluczowego 'new' do stworzenia obiektu
Samochod auto = new Samochod("Tesla", "S"); //W C# obiekty klas zawsze tworzymy za pomocą słowa new. Powoduje to utworzenie obiektu na tzw. stercie (zarządzanej pamięci).









